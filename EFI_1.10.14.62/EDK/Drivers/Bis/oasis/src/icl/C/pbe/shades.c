/*

Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

*/

/* 
 * WARNING: EXPORT RESTRICTED. 
 * This software is subject to the U.S. Export Administration Regulations 
 * and other U.S. law, and may not be exported or re-exported to certain 
 * countries (currently Afghanistan (Taliban-controlled areas), Cuba, Iran, 
 * Iraq, Libya, North Korea, Serbia (except Kosovo), Sudan and Syria) or to 
 * persons or entities prohibited from receiving U.S. exports (including Denied 
 * Parties, Specially Designated Nationals, and entities on the Bureau of 
 * Export Administration Entity List or involved with missile technology or 
 * nuclear, chemical or biological weapons).
 */ 

/*
 *  INTEL CONFIDENTIAL
 *  This file, software, or program is supplied under the terms
 *  of a licence agreement or nondisclosure agreement with
 *  Intel Corporation and may not be copied or disclosed except
 *  in accordance with the terms of that agreement. This file,
 *  software, or program contains copyrighted material and/or
 *  trade secret information of Intel Corporation, and must be
 *  treated as such. Intel reserves all rights in this material,
 *  except as the licence agreement or nondisclosure agreement
 *  specifically indicate.
*/

/* Module name: shades.c
Password Based Encryption: SHA with DES.
*/

//#include <stddef.h>
#include "../../include/icl.h"

int __stdcall ICL_PBEwithSHADES
    (ICLData        *PlainText,
    ICLPassPhrase   PassPhrase,
    int             IterationCount,
    ICLSalt         *Salt,
    ICLData         *CipherText)
{
  ICLData		HashInput, RemainingOutput;
  ICLByte		array[MAXPASSPHRASELENGTH + 2*sizeof (ICLWord)+1];
  ICLByte		rarray[24];
  ICLData       SaltValue;  /* to be used in Random Number Generator */
  ICLSalt		SeedValue;
  int			cnt;

  ICLSHAState   SHAState;
  ICLSHADigest  SHADigest;

  ICLDESState   DESState;
  ICLDESIV      DESIV;
  ICLDESKey     DESKey;


  RemainingOutput.value = rarray;
  SaltValue.value = (ICLByte *)Salt;
  SaltValue.length = 8;
  HashInput.value = array;

/* Use digest of the passphrase as the seed of ICL_RandGen */
    for (cnt=0; cnt<MAXPASSPHRASELENGTH && PassPhrase[cnt]!='\0'; ++cnt)
        array[cnt] = PassPhrase[cnt];
    HashInput.length = cnt;

/* digest the passphrase to get the seed value. */
    ICL_SHABegin (&SHAState);
    ICL_SHAProcess (&HashInput, &SHAState);
    ICL_SHAEnd (&SHAState, SHADigest);
/* The higher 64-bit of the digest is exored with
   the lower 64-bit of the digest to get 64-bit seed
*/  
    SeedValue[0] = ((ICLWord *)SHADigest)[0] ^ ((ICLWord *)SHADigest)[2];
    SeedValue[1] = ((ICLWord *)SHADigest)[1] ^ ((ICLWord *)SHADigest)[3];
/* Get a random value for Salt */
    ICL_RandGen (SeedValue, 2*sizeof (ICLWord), &SaltValue);

/* pack the PassPhrase and the generated random value (i.e., salt).
   Concat Salt to the end (lower words) of PassPhrase to get
   the string (PassPhrase,Salt) to construct Hash function input
*/
    ((ICLWord *)array)[0] = ((ICLWord *)*Salt)[0];
    ((ICLWord *)array)[1] = ((ICLWord *)*Salt)[1];

/* copy PassPhrase to the higher words of MD5Input */
    for (cnt=0; cnt<MAXPASSPHRASELENGTH && PassPhrase[cnt]!='\0'; ++cnt)
        array[cnt+2*sizeof (ICLWord)] = PassPhrase[cnt];
    HashInput.length = 2*sizeof(ICLWord) + cnt;

/* run digest algorithm IterationCount times */
    while (IterationCount-->0) {
        ICL_SHABegin (&SHAState);					/* init. the hash function,	*/
        ICL_SHAProcess (&HashInput, &SHAState);		/* process the input and ..	*/
        ICL_SHAEnd (&SHAState, SHADigest);			/* .. get the digest		*/
        ((ICLWord *)HashInput.value)[0] = ((ICLWord *)SHADigest)[0];
        ((ICLWord *)HashInput.value)[1] = ((ICLWord *)SHADigest)[1];
        ((ICLWord *)HashInput.value)[2] = ((ICLWord *)SHADigest)[2];
        ((ICLWord *)HashInput.value)[3] = ((ICLWord *)SHADigest)[3];
        ((ICLWord *)HashInput.value)[4] = ((ICLWord *)SHADigest)[4];
        HashInput.length = 160/8;
    }
/* Construct Encryption Secret Key and IV from the output of Hash function */
    ((ICLWord *)DESKey)[1] = ((ICLWord *)SHADigest)[3];
    ((ICLWord *)DESKey)[0] = ((ICLWord *)SHADigest)[2];
    ((ICLWord *)DESIV)[1]  = ((ICLWord *)SHADigest)[1];
    ((ICLWord *)DESIV)[0]  = ((ICLWord *)SHADigest)[0];

/* encrypt the input PlainText with the key and IV generated by MD5 */
    ICL_DESBeginCBC (DESKey, DESIV, &DESState);
    ICL_DESEncryptCBC (PlainText, &DESState, CipherText);
    ICL_DESEndCBC (&DESState, &RemainingOutput);

/* append the remaining output at the end of ciphertext */
	IterationCount = CipherText->length;
	for (cnt=0; cnt<RemainingOutput.length; ++cnt)
		CipherText->value[IterationCount+cnt] = rarray[cnt];
	CipherText->length += RemainingOutput.length;

    return 0;
}



int __stdcall ICL_PBDwithSHADES (ICLData *CipherText,
                             ICLPassPhrase PassPhrase,
                             int IterationCount,
                             ICLSalt Salt,
                             ICLData *PlainText)
{
    ICLData         HashInput, RemainingOutput;
    ICLByte         array[MAXPASSPHRASELENGTH + 2*sizeof(ICLWord)];
	ICLByte			rarray[24];
    int             cnt;
    ICLSHAState     SHAState;
    ICLSHADigest    SHADigest;
    ICLDESState     DESState;
    ICLDESIV        DESIV;
    ICLDESKey       DESKey;

    HashInput.value = array;
	RemainingOutput.value = rarray;

/* pack the PassPhrase and the generated random value (i.e., salt)
   (PassPhrase,Salt) to construct the Hash function input
*/
    ((ICLWord *)array)[0] = Salt[0];		/* bytes 0-3 */
    ((ICLWord *)array)[1] = Salt[1];		/* bytes 4-7 */

/* copy PassPhrase to the higher words of HashInput */
    for (cnt=0; cnt<MAXPASSPHRASELENGTH && PassPhrase[cnt]!='\0'; ++cnt)
        array[cnt + 2*sizeof(ICLWord)] = PassPhrase[cnt];
    HashInput.length = 2*sizeof (ICLWord) + cnt;

/* run SHA IterationCount times */
    while (IterationCount-->0) {
        ICL_SHABegin (&SHAState);
        ICL_SHAProcess (&HashInput, &SHAState);
        ICL_SHAEnd (&SHAState, SHADigest);
        ((ICLWord *)HashInput.value)[0] = ((ICLWord *)SHADigest)[0];
        ((ICLWord *)HashInput.value)[1] = ((ICLWord *)SHADigest)[1];
        ((ICLWord *)HashInput.value)[2] = ((ICLWord *)SHADigest)[2];
        ((ICLWord *)HashInput.value)[3] = ((ICLWord *)SHADigest)[3];
        HashInput.length = 160/8;
    }
/* Construct Decryption Secret Key and IV from the output of Hash function */
    ((ICLWord *)DESKey)[1] = ((ICLWord *)SHADigest)[3];
    ((ICLWord *)DESKey)[0] = ((ICLWord *)SHADigest)[2];
    ((ICLWord *)DESIV)[1]  = ((ICLWord *)SHADigest)[1];
    ((ICLWord *)DESIV)[0]  = ((ICLWord *)SHADigest)[0];

/* encrypt the input PlainText with the key and IV generated by Hash function */
    ICL_DESBeginCBC (DESKey, DESIV, &DESState);
    ICL_DESDecryptCBC (CipherText, &DESState, PlainText);
    ICL_DESEndCBC (&DESState, &RemainingOutput);

/* append the remaining output at the end of plaintext */
	IterationCount = PlainText->length;
	for (cnt=0; cnt<RemainingOutput.length; ++cnt)
		PlainText->value[IterationCount+cnt] = rarray[cnt];
	PlainText->length += RemainingOutput.length;

    return 0;
}
